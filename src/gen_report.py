#!/usr/bin/env python3
import os
import mne
from datetime import datetime
import glob
import shutil
import json
import logging
import traceback
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import subprocess

# Import logging config
from sync_org import logger

# Configuration
LOCAL_FIG_PATH = "/home/co/data/mne_reports/figures/"
LOCAL_REPORT_PATH = "/home/co/data/mne_reports/"
GITHUB_REPO_PATH = "/home/co/git/pi-aiche-dee/"
GITHUB_FILES_PATH = os.path.join(GITHUB_REPO_PATH, "files")
METADATA_FILE = os.path.join(LOCAL_FIG_PATH, "metadata.json")

# Email configuration
EMAIL_CONFIG = {
    'enabled': True,
    'sender': 'corentiinbel@gmail.com',
    'password': os.getenv('EMAIL_PASSWORD'),  # Use environment variable for password
    'recipients': ['corentin.bel@protonmail.com'],
    'smtp_server': 'smtp.gmail.com',
    'smtp_port': 587
}

def read_metadata():
    """Read the metadata database"""
    try:
        if os.path.exists(METADATA_FILE):
            with open(METADATA_FILE, 'r') as f:
                return json.load(f)
        else:
            logger.warning("Metadata file not found")
            return {}
    except Exception as e:
        logger.error(f"Error reading metadata: {str(e)}")
        return {}

def get_section_title(category_path):
    """Generate a human-readable section title from the path"""
    category = os.path.basename(category_path)
    return category.replace('_', ' ').title()

def group_figures_by_metadata(category_path, metadata_db):
    """Group figures within a category by metadata attributes"""
    figures = glob.glob(os.path.join(category_path, "*.png"))
    
    # Group by task, then by subject
    grouped = {}
    
    for fig_path in figures:
        filename = os.path.basename(fig_path)
        if filename in metadata_db:
            meta = metadata_db[filename]
            task = meta.get('task', 'unknown_task')
            subject = meta.get('subject', 'unknown_subject')
            condition = meta.get('condition', 'unknown_condition')
            
            # Create nested structure
            if task not in grouped:
                grouped[task] = {}
            if subject not in grouped[task]:
                grouped[task][subject] = {}
            if condition not in grouped[task][subject]:
                grouped[task][subject][condition] = []
                
            grouped[task][subject][condition].append((fig_path, filename, meta))
        else:
            # No metadata, add to unknown group
            if 'unknown' not in grouped:
                grouped['unknown'] = {'unknown': {'unknown': []}}
            grouped['unknown']['unknown']['unknown'].append((fig_path, filename, {}))
    
    return grouped

def get_experiment_description(experiment_name):
    """Get a description for each experiment type based on the experiment name"""
    descriptions = {
        "mindsentences": {
            "short": "An experiment examining neural responses to auditory language processing using MEG. This study focuses on syntax building and word decoding for controlled and naturalistic stimuli.",
            "full": """The Mindsentences experiment investigates neural responses to auditory sentence processing using MEG/EEG. 
                    Participants listen to spoken sentences and repeat them inside their heads while their brain activity is recorded.
                    The stimuli consist of 20K natural sentences generated by an LLM and then transcribed to speech using
                    Seamless4Tv2-large or OpenAI. Sentences were controlled for length (4-12 words),
                    syntactic complexity, naturalness and comprehensibility."""
        },
        "distraction": {
            "short": "This experiment investigates how distractions impact neural dynamics of speech comprehension. Different types of distractions (math, memory tasks, etc.) are presented every other normal listening run.",
            "full": """The Distraction experiment investigates how participants maintain focus during cognitive tasks while 
                    exposed to controlled distraction stimuli. We measure neural responses using EEG/MEG to understand the 
                    interplay between attention, cognitive control, and distraction resistance.
                    Participants performed a primary visual task while being exposed to auditory 
                    distractors with varying levels of salience and relevance."""
        },
        "probe": {
            "short": "An experiment where we try to probe both the brain and language models looking for syntactic cues.",
            "full": """The Probe experiment uses precisely timed stimuli to isolate specific neural processes in cognitive 
                    processing. By carefully controlling the timing of probe stimuli, we can observe how different stages 
                    of processing interact and develop over time.
                    In this protocol, participants are presented with a primary task, and at precise time intervals, 
                    probe stimuli are introduced to measure the ongoing neural processes."""
        },
        "expertlm": {
            "short": "Research exploring how preprompting a LLM with some expert qualification would change its embeddings, processing of information, and ultimately brain scores.",
            "full": """The ExpertLM experiment investigates how domain expertise affects language processing and comprehension.
                    By comparing neural responses between expert and novice participants, we can identify how expertise 
                    shapes neural representations and processing efficiency.
                    We recorded neural responses (MEG/EEG) from participants with varying levels of domain expertise 
                    while they processed both domain-specific and general language stimuli."""
        },
        # Add more experiment descriptions as needed
    }
    
    # Default description for unrecognized experiments
    default_desc = {
        "short": "MEG Weekly Analysis Report.",
        "full": "This analysis examines neural data collected using magnetoencephalography (MEG) and/or electroencephalography (EEG) to investigate brain activity patterns related to this experimental paradigm."
    }
    
    return descriptions.get(experiment_name.lower(), default_desc)

def extract_main_component(filename):
    """
    Extract the first substring from a filename as the main component
    (e.g., 'probe' from 'probe_spacy_to_probe.png')
    """
    # Remove file extension and split by underscore
    base_name = os.path.splitext(filename)[0]
    parts = base_name.split('_')
    
    # Get the first part as the main component
    if parts and len(parts) > 0:
        return parts[0].lower()
    else:
        return "unknown"

def parse_remaining_components(filename, main_component):
    """
    Parse the remaining parts of the filename after the main component
    to create subcategories
    """
    # Remove file extension and split by underscore
    base_name = os.path.splitext(filename)[0]
    parts = base_name.split('_')
    
    # Skip the first part (main component)
    remaining_parts = parts[1:] if len(parts) > 1 else []
    
    # Filter out very short parts or common non-descriptive terms
    filtered_parts = []
    common_terms = ['sub', 'ses', 'run', 'img', 'fig', 'the', 'and', 'for', 'to']
    
    for part in remaining_parts:
        if len(part) >= 3 and not part.isdigit() and part.lower() not in common_terms:
            filtered_parts.append(part.lower())
    
    return filtered_parts

def group_figures_hierarchically(figures, metadata_db):
    """
    Group figures hierarchically - first by main component, then by subcategories
    derived from remaining filename parts
    """
    main_categories = {}
    
    for fig_path in figures:
        filename = os.path.basename(fig_path)
        
        # Get main component (first substring)
        main_component = extract_main_component(filename)
        
        # Create main category if it doesn't exist
        if main_component not in main_categories:
            main_categories[main_component] = {'figures': [], 'subcategories': {}}
        
        # Add to the main category's figure list
        main_categories[main_component]['figures'].append(
            (fig_path, filename, metadata_db.get(filename, {}))
        )
        
        # Extract subcategories from remaining parts of the filename
        subcategories = parse_remaining_components(filename, main_component)
        
        # If we have subcategories, add to respective subcategory
        if subcategories:
            # Use the first subcategory as the grouping key
            subcat_key = subcategories[0]
            
            if subcat_key not in main_categories[main_component]['subcategories']:
                main_categories[main_component]['subcategories'][subcat_key] = []
            
            main_categories[main_component]['subcategories'][subcat_key].append(
                (fig_path, filename, metadata_db.get(filename, {}))
            )
    
    return main_categories

def generate_mne_report(custom_date=None):
    """Generate an MNE report from the organized figures with improved organization and layout"""
    try:
        # Create a new report with a more specific title
        report = mne.Report(title='MEG Weekly Analysis Report')
        
        # Get current date for report naming, or use custom date if provided
        if custom_date:
            current_date = custom_date.strftime("%Y-%m-%d")
        else:
            current_date = datetime.now().strftime("%Y-%m-%d")
        
        # Read metadata database
        metadata_db = read_metadata()
        
        # Get all top-level category directories
        category_dirs = [d for d in os.listdir(LOCAL_FIG_PATH) 
                        if os.path.isdir(os.path.join(LOCAL_FIG_PATH, d))]
        
        # Custom CSS for better formatting and smaller figures
        custom_css = """
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                line-height: 1.6;
                color: #333;
                background-color: #f8f9fa;
            }
            
            .mne-report-section {
                margin-bottom: 30px;
                background-color: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .mne-report-section h2 {
                padding: 10px 15px;
                background-color: #e7f5ff;
                border-left: 5px solid #1e88e5;
                margin: 20px 0;
                border-radius: 0 4px 4px 0;
                font-size: 1.5em;
            }
            
            .mne-report-section h3 {
                margin-top: 25px;
                border-bottom: 2px solid #bbdefb;
                padding-bottom: 5px;
                color: #1976d2;
                font-size: 1.3em;
            }
            
            .mne-report-section h4 {
                margin-top: 15px;
                color: #2962ff;
                font-size: 1.1em;
            }
            
            .mne-report-section figure {
                box-shadow: 0 1px 3px rgba(0,0,0,0.12);
                padding: 15px;
                margin: 15px 0;
                transition: transform 0.2s;
                max-width: 650px;
                background-color: white;
                border-radius: 4px;
            }
            
            .mne-report-section figure:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }
            
            .mne-report-section img {
                max-width: 100%;
                height: auto;
            }
            
            .mne-report-section figcaption {
                font-size: 13px;
                margin-top: 10px;
                font-style: italic;
                color: #505050;
                border-top: 1px solid #eee;
                padding-top: 8px;
            }
            
            .experiment-description {
                background-color: #f0f7fb;
                padding: 15px;
                border-left: 3px solid #1e88e5;
                margin: 15px 0;
                font-size: 14px;
                border-radius: 0 4px 4px 0;
            }
            
            .figure-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                grid-gap: 20px;
                margin: 20px 0;
            }
            
            .overview-container {
                background-color: #e3f2fd;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 25px;
                border-left: 5px solid #1e88e5;
                color: #0d47a1;
            }
            
            .overview-container h2 {
                margin-top: 0;
                color: #0d47a1;
                background: none;
                border-left: none;
                padding: 0;
            }
            
            .toc-container {
                background-color: #fff;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 20px;
                margin: 20px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .toc-container h3 {
                margin-top: 0;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 10px;
                color: #1976d2;
            }
            
            .toc-container ul {
                list-style-type: none;
                padding-left: 5px;
            }
            
            .toc-container li {
                margin-bottom: 8px;
                padding-left: 15px;
                position: relative;
            }
            
            .toc-container li:before {
                content: '•';
                position: absolute;
                left: 0;
                color: #1e88e5;
            }
            
            .toc-container a {
                text-decoration: none;
                color: #1976d2;
                font-weight: 500;
                transition: all 0.2s;
            }
            
            .toc-container a:hover {
                color: #0d47a1;
                padding-left: 3px;
            }
            
            .date-stamp {
                color: #666;
                font-style: italic;
                margin-bottom: 15px;
            }
            
            .figures-summary {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin: 15px 0;
            }
            
            .figure-stat {
                background-color: #bbdefb;
                padding: 8px 15px;
                border-radius: 20px;
                font-weight: 500;
                color: #0d47a1;
            }
            
            .experiment-container {
                margin-bottom: 30px;
                padding: 20px;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .experiment-heading {
                font-size: 1.4em;
                color: #0d47a1;
                border-bottom: 2px solid #bbdefb;
                padding-bottom: 10px;
                margin-bottom: 15px;
            }
            
            .experiment-full-description {
                background-color: #f5f5f5;
                padding: 15px;
                border-radius: 5px;
                margin: 15px 0;
                font-size: 14px;
                line-height: 1.6;
            }
            
            .subcategory-container {
                margin: 15px 0 30px 0;
                padding: 15px;
                background-color: #f8f9fa;
                border-radius: 6px;
                border-left: 3px solid #bbdefb;
            }
            
            .subcategory-heading {
                font-size: 1.2em;
                color: #1976d2;
                margin-bottom: 15px;
            }
            
            .no-subcategory-container {
                margin-top: 20px;
            }
        </style>
        """
        
        # Add custom CSS to the report
        report.add_custom_css(custom_css)
        
        # Count total figures
        total_figures = 0
        for category in category_dirs:
            category_path = os.path.join(LOCAL_FIG_PATH, category)
            figures = glob.glob(os.path.join(category_path, "**/*.png"), recursive=True)
            total_figures += len(figures)
        
        # Get unique subjects and tasks
        subjects = set()
        tasks = set()
        main_components = set()
        for meta in metadata_db.values():
            if 'subject' in meta:
                subjects.add(meta['subject'])
            if 'task' in meta:
                tasks.add(meta['task'])
            
            # Extract main component from filename
            if 'filename' in meta:
                main_component = extract_main_component(meta['filename'])
                if main_component and main_component != 'unknown':
                    main_components.add(main_component)
        
        # Add overview section
        overview_html = f"""
        <div class="overview-container">
            <h2>MEG Weekly Analysis Report</h2>
            <p class="date-stamp">Generated on {datetime.strptime(current_date, '%Y-%m-%d').strftime('%A, %B %d, %Y')}</p>
            
            <p>This report contains MEG/EEG analysis results from the past week.</p>
            
            <div class="figures-summary">
                <span class="figure-stat">{total_figures} figures</span>
                <span class="figure-stat">{len(subjects)} subjects</span>
                <span class="figure-stat">{len(tasks)} tasks</span>
                <span class="figure-stat">{len(main_components)} experiment types</span>
            </div>
        </div>
        """
        report.add_html(overview_html, title="Overview")
        
        # Create collection of all figures across categories
        all_figures = []
        for category in category_dirs:
            category_path = os.path.join(LOCAL_FIG_PATH, category)
            figures = glob.glob(os.path.join(category_path, "**/*.png"), recursive=True)
            all_figures.extend(figures)
        
        # Group all figures hierarchically
        hierarchical_groups = group_figures_hierarchically(all_figures, metadata_db)
        
        # Create table of contents based on main components
        toc_items = []
        for main_component in sorted(hierarchical_groups.keys()):
            if main_component != 'unknown':  # Skip unknown category in TOC
                display_name = main_component.capitalize()
                toc_items.append(f'<li><a href="#{main_component.lower()}">{display_name}</a></li>')
        
        # Add "Other" category to TOC if we have unknown items
        if 'unknown' in hierarchical_groups:
            toc_items.append('<li><a href="#unknown">Other Figures</a></li>')
        
        # Add table of contents
        toc_html = f"""
        <div class="toc-container">
            <h3>Contents</h3>
            <ul>
                {''.join(toc_items)}
            </ul>
        </div>
        """
        report.add_html(toc_html, title="Table of Contents")
        
        # Process each main component group
        for main_component, group_data in sorted(hierarchical_groups.items()):
            figures = group_data['figures']
            subcategories = group_data['subcategories']
            
            if not figures:  # Skip empty groups
                continue
                
            # Get main component description (experiment description)
            main_desc = get_experiment_description(main_component)
            main_title = main_component.capitalize()
            
            # Add main component section header with anchor
            main_html = f"""
            <div id="{main_component.lower()}" class="experiment-container">
                <h2 class="experiment-heading">{main_title}</h2>
                
                <div class="experiment-description">
                    {main_desc.get('short', '')}
                </div>
                
                <div class="experiment-full-description">
                    {main_desc.get('full', '')}
                </div>
                
                <p><strong>Figures:</strong> {len(figures)}</p>
            </div>
            """
            report.add_html(main_html, title=main_title)
            
            # Add figures by subcategory
            if subcategories:
                for subcat_key, subcat_figures in sorted(subcategories.items()):
                    # Create readable subcategory title
                    subcat_title = subcat_key.replace('_', ' ').title()
                    
                    # Add subcategory container
                    subcat_html = f"""
                    <div class="subcategory-container">
                        <h3 class="subcategory-heading">{subcat_title}</h3>
                    </div>
                    """
                    report.add_html(subcat_html, title=f"{main_title} - {subcat_title}")
                    
                    # Add figures for this subcategory
                    for fig_path, filename, meta in subcat_figures:
                        # Create a descriptive title by removing main component and current subcategory
                        parts = os.path.splitext(filename)[0].split('_')
                        filtered_parts = [p for p in parts 
                                        if p.lower() != main_component.lower() 
                                        and p.lower() != subcat_key.lower()]
                        
                        if filtered_parts:
                            fig_title = ' '.join(word.capitalize() for word in filtered_parts)
                        else:
                            fig_title = filename
                        
                        # Add the figure
                        report.add_image(
                            image=fig_path,
                            title=fig_title,
                            caption=generate_caption(meta)
                        )
            
            # Add figures that weren't categorized into subcategories
            uncategorized_figures = []
            for fig_path, filename, meta in figures:
                # Check if this figure is already in a subcategory
                in_subcategory = False
                for subcat_figures in subcategories.values():
                    if any(f[1] == filename for f in subcat_figures):
                        in_subcategory = True
                        break
                
                if not in_subcategory:
                    uncategorized_figures.append((fig_path, filename, meta))
            
            # Add uncategorized figures section if there are any
            if uncategorized_figures:
                report.add_html(
                    '<div class="no-subcategory-container"><h3>General</h3></div>',
                    title=f"{main_title} - General"
                )
                
                for fig_path, filename, meta in uncategorized_figures:
                    # Create a descriptive title by removing main component
                    parts = os.path.splitext(filename)[0].split('_')
                    filtered_parts = [p for p in parts 
                                     if p.lower() != main_component.lower()]
                    
                    if filtered_parts:
                        fig_title = ' '.join(word.capitalize() for word in filtered_parts)
                    else:
                        fig_title = filename
                    
                    # Add the figure
                    report.add_image(
                        image=fig_path,
                        title=fig_title,
                        caption=generate_caption(meta)
                    )
        
        # Save the report
        report_filename = f"mne_report_{current_date}.html"
        report_path = os.path.join(LOCAL_REPORT_PATH, report_filename)
        report.save(report_path, overwrite=True)
        
        logger.info(f"Report generated at: {report_path}")
        return report_path, current_date
    
    except Exception as e:
        logger.error(f"Error generating report: {str(e)}")
        logger.error(traceback.format_exc())
        return None, datetime.now().strftime("%Y-%m-%d")

def generate_caption(metadata):
    """Generate a concise, descriptive caption from metadata"""
    if not metadata:
        return "No metadata available"
    
    # Focus on the most important fields and make caption concise
    important_fields = ['task', 'condition', 'analysis_type']
    secondary_fields = ['subject', 'component', 'timestamp']
    
    caption_parts = []
    
    # Add primary information first
    for key in important_fields:
        if key in metadata and metadata[key]:
            # Format and add field
            value = metadata[key]
            # Make task and analysis_type more readable
            if key == 'task' or key == 'analysis_type':
                value = value.replace('_', ' ').title()
            caption_parts.append(f"{key.replace('_', ' ').title()}: {value}")
    
    # Add secondary information if available
    for key in secondary_fields:
        if key in metadata and metadata[key]:
            # Format date differently
            if key == 'timestamp':
                caption_parts.append(f"Date: {metadata[key]}")
            else:
                caption_parts.append(f"{key.replace('_', ' ').title()}: {metadata[key]}")
    
    # Join parts with a separator
    return " | ".join(caption_parts) if caption_parts else "No metadata available"

def update_github_website(report_path, date):
    """Copy the report to the GitHub repo and update the website"""
    try:
        # Create weekly directory structure if needed
        week_dir = get_week_directory(date)
        github_week_dir = os.path.join(GITHUB_FILES_PATH, week_dir)
        os.makedirs(github_week_dir, exist_ok=True)
        
        # Copy the report to the GitHub repo
        report_filename = os.path.basename(report_path)
        github_report_path = os.path.join(github_week_dir, report_filename)
        shutil.copy2(report_path, github_report_path)
        
        # Update index.html
        update_index_html(report_filename, week_dir, date)
        
        # Commit and push changes
        git_commit_and_push(f"Update MNE report on the {date}")
        
        # Send success notification
        # send_email_notification(
        #     subject=f"MNE Report Updated - {date}",
        #     body=f"Successfully generated and published MNE report for {date}.\n\nReport is available at: https://your-github-pages-url/files/{week_dir}/{report_filename}",
        #     success=True
        # )
        
        logger.info(f"GitHub website updated with report: {github_report_path}")
        return True
    except Exception as e:
        logger.error(f"Error updating GitHub website: {str(e)}")
        logger.error(traceback.format_exc())
        # send_email_notification(
        #     subject="GitHub Website Update Failed",
        #     body=f"Error updating GitHub website: {str(e)}\n\n{traceback.format_exc()}",
        #     success=False
        # )
        return False

def get_week_directory(date_str):
    """Convert date to a week directory name"""
    date_obj = datetime.strptime(date_str, "%Y-%m-%d")
    year = date_obj.year
    # Calculate week of year
    week_num = date_obj.isocalendar()[1]
    return f"week{week_num}_{year}"

def update_index_html(report_filename, week_dir, date_str):
    """Update the index.html file to include the new report"""
    try:
        index_path = os.path.join(GITHUB_REPO_PATH, "index.html")
        
        with open(index_path, 'r') as file:
            content = file.read()
        
        # Format date for display
        date_obj = datetime.strptime(date_str, "%Y-%m-%d")
        formatted_date = date_obj.strftime("%A, %B %d, %Y")
        
        # Get metadata summary for the report
        metadata_db = read_metadata()
        total_figures = len(metadata_db)
        subjects = set(meta.get('subject', 'unknown') for meta in metadata_db.values())
        tasks = set(meta.get('task', 'unknown') for meta in metadata_db.values())
        
        # Create a section ID for the meeting date
        meeting_id = f"meeting-{date_str}"
        
        # Check if this meeting section already exists in the page
        if meeting_id in content:
            # If section exists, update the MNE report link
            logger.info(f"Found existing meeting section for {date_str}, updating report link")
            
            # Find the report link and update it
            report_link_pattern = f'<a href="files/[^"]+" class="report-link">View MNE Report</a>'
            new_report_link = f'<a href="files/{week_dir}/{report_filename}" class="report-link">View MNE Report</a>'
            
            # Use regular expression to replace the link
            import re
            updated_content = re.sub(report_link_pattern, new_report_link, content)
            
            # Write the updated content back to the file
            with open(index_path, 'w') as file:
                file.write(updated_content)
            
            logger.info(f"Updated index.html with new report link for {date_str}")
            return True
        
        else:
            # If section doesn't exist, this is an old meeting that should be archived
            logger.warning(f"Could not find meeting section for {date_str} in index.html")
            
            # Instead of failing, we'll just log the warning and continue
            return True
    except Exception as e:
        logger.error(f"Error updating index.html: {str(e)}")
        return False

def git_commit_and_push(commit_message):
    """Commit and push changes to GitHub"""
    try:
        os.chdir(GITHUB_REPO_PATH)
        
        # Add all changes
        subprocess.run(["git", "add", "."], check=True)
        
        # Commit
        subprocess.run(["git", "commit", "-m", commit_message], check=True)
        
        # Push
        subprocess.run(["git", "push"], check=True)
        
        logger.info("Changes committed and pushed to GitHub")
        return True
    except subprocess.CalledProcessError as e:
        logger.error(f"Git error: {str(e)}")
        return False
    except Exception as e:
        logger.error(f"Error in git operations: {str(e)}")
        return False

def send_email_notification(subject, body, success=True):
    """Send email notification about pipeline status"""
    if not EMAIL_CONFIG['enabled']:
        logger.info("Email notifications disabled")
        return
    
    try:
        msg = MIMEMultipart()
        msg['From'] = EMAIL_CONFIG['sender']
        msg['To'] = ', '.join(EMAIL_CONFIG['recipients'])
        
        # Add success/failure indicator to subject
        prefix = "✅" if success else "❌"
        msg['Subject'] = f"{prefix} {subject}"
        
        # Body content
        msg.attach(MIMEText(body, 'plain'))
        
        # Attach log file if it exists
        log_file = "pipeline.log"
        if os.path.exists(log_file):
            with open(log_file, 'rb') as f:
                log_attachment = MIMEApplication(f.read(), Name=os.path.basename(log_file))
                log_attachment['Content-Disposition'] = f'attachment; filename="{os.path.basename(log_file)}"'
                msg.attach(log_attachment)
        
        # Connect to server and send
        server = smtplib.SMTP(EMAIL_CONFIG['smtp_server'], EMAIL_CONFIG['smtp_port'])
        server.starttls()
        server.login(EMAIL_CONFIG['sender'], EMAIL_CONFIG['password'])
        server.send_message(msg)
        server.quit()
        
        logger.info(f"Email notification sent: {subject}")
    except Exception as e:
        logger.error(f"Failed to send email notification: {str(e)}")

if __name__ == "__main__":
    report_path, date = generate_mne_report()
    if report_path:
        update_github_website(report_path, date)